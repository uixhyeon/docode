{
  "html-css": {
    "flexbox": {
      "title": "Flexbox - 유연한 레이아웃 시스템",
      "content": "# Flexbox\n\n## 개념\nFlexbox는 CSS의 레이아웃 모델로, 컨테이너 내의 아이템들을 효율적으로 정렬하고 배치할 수 있게 해줍니다. 복잡한 레이아웃을 간단하게 구현할 수 있으며, 반응형 디자인에 매우 유용합니다.\n\n## 주요 코드\n\n### 기본 설정\n```css\n.container {\n  display: flex;\n  /* 기본 방향: 가로 */\n  flex-direction: row;\n  /* 줄바꿈 허용 */\n  flex-wrap: wrap;\n  /* 주축 정렬 */\n  justify-content: space-between;\n  /* 교차축 정렬 */\n  align-items: center;\n  gap: 1rem;\n}\n```\n\n### Flex Item 속성\n```css\n.item {\n  /* 증가 비율 */\n  flex-grow: 1;\n  /* 감소 비율 */\n  flex-shrink: 1;\n  /* 기본 크기 */\n  flex-basis: 200px;\n  /* 축약형 */\n  flex: 1 1 200px;\n}\n```\n\n## 설명\n- **flex-direction**: 아이템 배치 방향 설정 (row, column, row-reverse, column-reverse)\n- **justify-content**: 주축 방향 정렬 (flex-start, center, space-between, space-around)\n- **align-items**: 교차축 방향 정렬 (flex-start, center, stretch, baseline)\n- **flex-grow**: 남은 공간을 어떻게 분배할지 결정\n- **flex-shrink**: 공간이 부족할 때 얼마나 줄어들지 결정"
    },
    "grid": {
      "title": "CSS Grid - 2차원 레이아웃 시스템",
      "content": "# CSS Grid\n\n## 개념\nCSS Grid는 2차원 레이아웃 시스템으로, 행과 열을 동시에 다룰 수 있습니다. 복잡한 레이아웃을 쉽게 구현할 수 있으며, Flexbox와 함께 사용하면 강력한 레이아웃을 만들 수 있습니다.\n\n## 주요 코드\n\n### 기본 Grid 설정\n```css\n.container {\n  display: grid;\n  /* 열 정의 */\n  grid-template-columns: repeat(3, 1fr);\n  /* 행 정의 */\n  grid-template-rows: 100px auto 100px;\n  /* 간격 */\n  gap: 1rem;\n}\n```\n\n### Grid Item 배치\n```css\n.item {\n  /* 열 시작/끝 */\n  grid-column: 1 / 3;\n  /* 행 시작/끝 */\n  grid-row: 1 / 2;\n  /* 축약형 */\n  grid-area: 1 / 1 / 2 / 3;\n}\n```\n\n### 반응형 Grid\n```css\n.container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: 1rem;\n}\n```\n\n## 설명\n- **grid-template-columns/rows**: 열과 행의 크기 정의\n- **fr**: fraction unit, 사용 가능한 공간의 비율\n- **repeat()**: 반복 패턴 정의\n- **auto-fit/auto-fill**: 자동으로 열 개수 조정\n- **minmax()**: 최소/최대 크기 설정"
    },
    "semantic-html": {
      "title": "Semantic HTML - 의미있는 HTML 작성",
      "content": "# Semantic HTML\n\n## 개념\nSemantic HTML은 HTML 태그를 의미에 맞게 사용하는 것을 의미합니다. 검색 엔진 최적화(SEO)와 접근성(Accessibility)을 향상시키며, 코드의 가독성을 높입니다.\n\n## 주요 코드\n\n```html\n<header>\n  <nav>\n    <ul>\n      <li><a href=\"/\">홈</a></li>\n      <li><a href=\"/about\">소개</a></li>\n    </ul>\n  </nav>\n</header>\n\n<main>\n  <article>\n    <h1>게시글 제목</h1>\n    <section>\n      <h2>섹션 제목</h2>\n      <p>내용...</p>\n    </section>\n  </article>\n  \n  <aside>\n    <h2>관련 정보</h2>\n  </aside>\n</main>\n\n<footer>\n  <p>&copy; 2024 회사명</p>\n</footer>\n```\n\n## 설명\n- **header**: 페이지나 섹션의 헤더\n- **nav**: 네비게이션 링크 그룹\n- **main**: 문서의 주요 콘텐츠\n- **article**: 독립적인 콘텐츠\n- **section**: 주제별 콘텐츠 그룹\n- **aside**: 부가 정보\n- **footer**: 페이지나 섹션의 푸터"
    }
  },
  "javascript": {
    "es6-syntax": {
      "title": "ES6+ 문법 - 현대 JavaScript의 핵심",
      "content": "# ES6+ 문법\n\n## 개념\nES6(ES2015)부터 도입된 현대 JavaScript의 주요 문법들입니다. 코드를 더 간결하고 읽기 쉽게 만들어줍니다.\n\n## 주요 코드\n\n### 구조 분해 할당\n```javascript\n// 배열 구조 분해\nconst [a, b, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(a, b, rest); // 1 2 [3, 4, 5]\n\n// 객체 구조 분해\nconst { name, age, ...others } = {\n  name: '홍길동',\n  age: 30,\n  city: '서울'\n};\n```\n\n### 화살표 함수\n```javascript\n// 기본 형태\nconst add = (a, b) => a + b;\n\n// 여러 줄\nconst greet = (name) => {\n  const message = `안녕하세요, ${name}님!`;\n  return message;\n};\n\n// this 바인딩 유지\nclass Counter {\n  count = 0;\n  \n  increment = () => {\n    this.count++; // this가 Counter를 가리킴\n  }\n}\n```\n\n### 템플릿 리터럴\n```javascript\nconst name = '철수';\nconst age = 25;\nconst message = `이름: ${name}, 나이: ${age}세`;\n\n// 여러 줄 문자열\nconst html = `\n  <div>\n    <h1>${name}</h1>\n    <p>나이: ${age}</p>\n  </div>\n`;\n```\n\n### Spread/Rest 연산자\n```javascript\n// Spread - 배열\nconst arr1 = [1, 2, 3];\nconst arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]\n\n// Spread - 객체\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }\n\n// Rest - 함수 매개변수\nfunction sum(...numbers) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n```\n\n## 설명\n- **구조 분해**: 배열이나 객체의 값을 쉽게 추출\n- **화살표 함수**: 간결한 함수 표현, this 바인딩 유지\n- **템플릿 리터럴**: 문자열 보간과 여러 줄 문자열 작성\n- **Spread**: 배열이나 객체를 펼침\n- **Rest**: 나머지 요소를 배열로 수집"
    },
    "async": {
      "title": "비동기 처리 - Promise와 async/await",
      "content": "# 비동기 처리\n\n## 개념\nJavaScript의 비동기 처리는 시간이 걸리는 작업을 기다리지 않고 다른 작업을 계속 실행할 수 있게 합니다. API 호출, 파일 읽기 등에 사용됩니다.\n\n## 주요 코드\n\n### Promise\n```javascript\n// Promise 생성\nconst fetchData = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const data = { id: 1, name: '데이터' };\n      resolve(data);\n      // 에러 시: reject(new Error('에러 발생'));\n    }, 1000);\n  });\n};\n\n// Promise 사용\nfetchData()\n  .then(data => console.log(data))\n  .catch(error => console.error(error))\n  .finally(() => console.log('완료'));\n```\n\n### async/await\n```javascript\n// async 함수\nasync function getData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('에러:', error);\n    throw error;\n  }\n}\n\n// 사용\ngetData().then(data => console.log(data));\n```\n\n### 병렬 처리\n```javascript\n// Promise.all - 모든 Promise 완료 대기\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(),\n  fetchPosts(),\n  fetchComments()\n]);\n\n// Promise.race - 가장 빠른 Promise만\nconst result = await Promise.race([\n  fetchFromServer1(),\n  fetchFromServer2()\n]);\n```\n\n### 순차 처리\n```javascript\nasync function processSequentially() {\n  const result1 = await step1();\n  const result2 = await step2(result1);\n  const result3 = await step3(result2);\n  return result3;\n}\n```\n\n## 설명\n- **Promise**: 비동기 작업의 완료 또는 실패를 나타내는 객체\n- **async/await**: Promise를 더 쉽게 사용할 수 있는 문법\n- **try/catch**: async 함수에서 에러 처리\n- **Promise.all**: 여러 Promise를 병렬로 실행\n- **Promise.race**: 가장 빨리 완료된 Promise 결과 반환"
    },
    "array-methods": {
      "title": "배열 메서드 - 데이터 처리의 핵심",
      "content": "# 배열 메서드\n\n## 개념\nJavaScript 배열의 고차 함수들은 데이터를 효율적으로 처리할 수 있게 해줍니다. 함수형 프로그래밍의 기초가 됩니다.\n\n## 주요 코드\n\n### map - 변환\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\n// [2, 4, 6, 8, 10]\n\nconst users = [\n  { id: 1, name: '철수' },\n  { id: 2, name: '영희' }\n];\nconst names = users.map(user => user.name);\n// ['철수', '영희']\n```\n\n### filter - 필터링\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(num => num % 2 === 0);\n// [2, 4]\n\nconst users = [\n  { name: '철수', age: 25 },\n  { name: '영희', age: 17 }\n];\nconst adults = users.filter(user => user.age >= 18);\n```\n\n### reduce - 집계\n```javascript\n// 합계\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\n// 15\n\n// 객체로 변환\nconst users = [\n  { id: 1, name: '철수' },\n  { id: 2, name: '영희' }\n];\nconst userMap = users.reduce((acc, user) => {\n  acc[user.id] = user.name;\n  return acc;\n}, {});\n// { 1: '철수', 2: '영희' }\n```\n\n### find/findIndex - 검색\n```javascript\nconst users = [\n  { id: 1, name: '철수' },\n  { id: 2, name: '영희' }\n];\n\nconst user = users.find(u => u.id === 2);\n// { id: 2, name: '영희' }\n\nconst index = users.findIndex(u => u.id === 2);\n// 1\n```\n\n### some/every - 조건 검사\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// 하나라도 만족하는지\nconst hasEven = numbers.some(num => num % 2 === 0);\n// true\n\n// 모두 만족하는지\nconst allPositive = numbers.every(num => num > 0);\n// true\n```\n\n## 설명\n- **map**: 각 요소를 변환하여 새 배열 생성\n- **filter**: 조건을 만족하는 요소만 포함하는 새 배열 생성\n- **reduce**: 배열을 단일 값으로 축소\n- **find/findIndex**: 조건을 만족하는 첫 번째 요소/인덱스 찾기\n- **some/every**: 배열 요소의 조건 검사"
    }
  },
  "typescript": {
    "basic-types": {
      "title": "TypeScript 기본 타입",
      "content": "# TypeScript 기본 타입\n\n## 개념\nTypeScript는 JavaScript에 정적 타입을 추가한 언어입니다. 타입 시스템을 통해 코드의 안정성과 가독성을 높일 수 있습니다.\n\n## 주요 코드\n\n### 기본 타입\n```typescript\n// 기본 타입\nlet name: string = '홍길동';\nlet age: number = 30;\nlet isActive: boolean = true;\nlet nothing: null = null;\nlet notDefined: undefined = undefined;\n\n// 배열\nlet numbers: number[] = [1, 2, 3];\nlet strings: Array<string> = ['a', 'b', 'c'];\n\n// 튜플\nlet tuple: [string, number] = ['홍길동', 30];\n\n// enum\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet color: Color = Color.Red;\n```\n\n### 객체 타입\n```typescript\n// 인터페이스\ninterface User {\n  id: number;\n  name: string;\n  email?: string; // 선택적 속성\n  readonly createdAt: Date; // 읽기 전용\n}\n\nconst user: User = {\n  id: 1,\n  name: '홍길동',\n  createdAt: new Date()\n};\n\n// Type alias\ntype Point = {\n  x: number;\n  y: number;\n};\n```\n\n### 함수 타입\n```typescript\n// 함수 선언\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// 화살표 함수\nconst multiply = (a: number, b: number): number => a * b;\n\n// 선택적 매개변수\nfunction greet(name: string, greeting?: string): string {\n  return `${greeting || 'Hello'}, ${name}!`;\n}\n\n// 기본값\nfunction createUser(name: string, age: number = 0): User {\n  return { id: 1, name, createdAt: new Date() };\n}\n```\n\n### Union과 Intersection\n```typescript\n// Union - 여러 타입 중 하나\ntype StringOrNumber = string | number;\nlet value: StringOrNumber = 'hello';\nvalue = 123;\n\n// Intersection - 여러 타입 결합\ntype Person = { name: string };\ntype Employee = { employeeId: number };\ntype Staff = Person & Employee;\n\nconst staff: Staff = {\n  name: '홍길동',\n  employeeId: 1234\n};\n```\n\n## 설명\n- **기본 타입**: string, number, boolean, null, undefined\n- **배열/튜플**: 여러 값을 저장하는 타입\n- **인터페이스**: 객체의 구조 정의\n- **Type alias**: 타입에 이름 부여\n- **Union**: 여러 타입 중 하나\n- **Intersection**: 여러 타입 결합"
    },
    "generics": {
      "title": "TypeScript 제네릭 - 재사용 가능한 타입",
      "content": "# TypeScript 제네릭\n\n## 개념\n제네릭은 타입을 매개변수화하여 재사용 가능한 컴포넌트를 만들 수 있게 합니다. 타입 안정성을 유지하면서도 유연한 코드를 작성할 수 있습니다.\n\n## 주요 코드\n\n### 기본 제네릭 함수\n```typescript\n// 제네릭 함수\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nconst num = identity<number>(123);\nconst str = identity<string>('hello');\nconst auto = identity(true); // 타입 추론\n\n// 배열 제네릭\nfunction getFirst<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\nconst first = getFirst([1, 2, 3]); // number\n```\n\n### 제네릭 인터페이스\n```typescript\ninterface Box<T> {\n  value: T;\n}\n\nconst numberBox: Box<number> = { value: 123 };\nconst stringBox: Box<string> = { value: 'hello' };\n\n// API 응답 타입\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\nconst userResponse: ApiResponse<User> = {\n  data: { id: 1, name: '홍길동', createdAt: new Date() },\n  status: 200,\n  message: 'Success'\n};\n```\n\n### 제네릭 클래스\n```typescript\nclass Stack<T> {\n  private items: T[] = [];\n\n  push(item: T): void {\n    this.items.push(item);\n  }\n\n  pop(): T | undefined {\n    return this.items.pop();\n  }\n\n  peek(): T | undefined {\n    return this.items[this.items.length - 1];\n  }\n}\n\nconst numberStack = new Stack<number>();\nnumberStack.push(1);\nnumberStack.push(2);\n```\n\n### 제네릭 제약\n```typescript\n// extends로 제약 추가\ninterface HasLength {\n  length: number;\n}\n\nfunction logLength<T extends HasLength>(item: T): void {\n  console.log(item.length);\n}\n\nlogLength('hello'); // OK\nlogLength([1, 2, 3]); // OK\n// logLength(123); // Error\n\n// keyof 사용\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { id: 1, name: '홍길동' };\nconst name = getProperty(user, 'name'); // string\n```\n\n### 유틸리티 타입과 제네릭\n```typescript\n// Partial - 모든 속성을 선택적으로\ntype PartialUser = Partial<User>;\n\n// Pick - 특정 속성만 선택\ntype UserPreview = Pick<User, 'id' | 'name'>;\n\n// Omit - 특정 속성 제외\ntype UserWithoutId = Omit<User, 'id'>;\n\n// Record - 키-값 타입\ntype UserMap = Record<number, User>;\n```\n\n## 설명\n- **제네릭 함수**: 타입을 매개변수로 받는 함수\n- **제네릭 인터페이스**: 재사용 가능한 타입 정의\n- **제네릭 클래스**: 다양한 타입을 다루는 클래스\n- **제네릭 제약**: extends로 타입 범위 제한\n- **유틸리티 타입**: 기존 타입을 변환하는 내장 제네릭"
    }
  },
  "react": {
    "hooks": {
      "title": "React Hooks - 함수형 컴포넌트의 핵심",
      "content": "# React Hooks\n\n## 개념\nHooks는 함수형 컴포넌트에서 상태와 라이프사이클 기능을 사용할 수 있게 해주는 React 기능입니다.\n\n## 주요 코드\n\n### useState - 상태 관리\n```jsx\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [user, setUser] = useState({ name: '', age: 0 });\n\n  const increment = () => setCount(count + 1);\n  const updateUser = () => setUser({ name: '홍길동', age: 30 });\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>증가</button>\n    </div>\n  );\n}\n```\n\n### useEffect - 부수 효과\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // 컴포넌트 마운트 시 실행\n    fetchData();\n    \n    // cleanup 함수\n    return () => {\n      // 컴포넌트 언마운트 시 실행\n      console.log('cleanup');\n    };\n  }, []); // 빈 배열: 마운트 시 한 번만\n\n  useEffect(() => {\n    // count 변경 시마다 실행\n    console.log('count changed');\n  }, [count]);\n\n  return <div>{loading ? 'Loading...' : JSON.stringify(data)}</div>;\n}\n```\n\n### useContext - 전역 상태\n```jsx\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext('light');\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Toolbar() {\n  const theme = useContext(ThemeContext);\n  return <div>Current theme: {theme}</div>;\n}\n```\n\n### useRef - 참조 저장\n```jsx\nimport { useRef, useEffect } from 'react';\n\nfunction InputFocus() {\n  const inputRef = useRef(null);\n  const countRef = useRef(0);\n\n  useEffect(() => {\n    // DOM 요소에 포커스\n    inputRef.current?.focus();\n  }, []);\n\n  const handleClick = () => {\n    // 리렌더링 없이 값 저장\n    countRef.current += 1;\n  };\n\n  return <input ref={inputRef} />;\n}\n```\n\n### useMemo & useCallback - 최적화\n```jsx\nimport { useMemo, useCallback } from 'react';\n\nfunction ExpensiveComponent({ items, filter }) {\n  // 계산 결과 메모이제이션\n  const filteredItems = useMemo(() => {\n    return items.filter(item => item.includes(filter));\n  }, [items, filter]);\n\n  // 함수 메모이제이션\n  const handleClick = useCallback((id) => {\n    console.log('Clicked:', id);\n  }, []);\n\n  return (\n    <ul>\n      {filteredItems.map(item => (\n        <li key={item} onClick={() => handleClick(item)}>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### Custom Hook\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    setLoading(true);\n    fetch(url)\n      .then(res => res.json())\n      .then(setData)\n      .catch(setError)\n      .finally(() => setLoading(false));\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// 사용\nfunction App() {\n  const { data, loading, error } = useFetch('/api/users');\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  return <div>{JSON.stringify(data)}</div>;\n}\n```\n\n## 설명\n- **useState**: 컴포넌트 상태 관리\n- **useEffect**: 부수 효과 처리 (API 호출, 구독 등)\n- **useContext**: Context API 사용\n- **useRef**: DOM 참조나 값 저장 (리렌더링 없음)\n- **useMemo**: 계산 결과 메모이제이션\n- **useCallback**: 함수 메모이제이션\n- **Custom Hook**: 재사용 가능한 로직 추출"
    },
    "state-management": {
      "title": "React 상태 관리",
      "content": "# React 상태 관리\n\n## 개념\nReact 애플리케이션에서 상태를 효율적으로 관리하는 다양한 패턴과 라이브러리들입니다.\n\n## 주요 코드\n\n### Context API + useReducer\n```jsx\nimport { createContext, useContext, useReducer } from 'react';\n\n// 액션 타입\nconst ActionTypes = {\n  ADD_TODO: 'ADD_TODO',\n  TOGGLE_TODO: 'TOGGLE_TODO',\n  DELETE_TODO: 'DELETE_TODO'\n};\n\n// 리듀서\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      return [...state, {\n        id: Date.now(),\n        text: action.payload,\n        completed: false\n      }];\n    case ActionTypes.TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload\n          ? { ...todo, completed: !todo.completed }\n          : todo\n      );\n    case ActionTypes.DELETE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\n// Context 생성\nconst TodoContext = createContext();\n\n// Provider 컴포넌트\nfunction TodoProvider({ children }) {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n\n  const value = {\n    todos,\n    addTodo: (text) => dispatch({ type: ActionTypes.ADD_TODO, payload: text }),\n    toggleTodo: (id) => dispatch({ type: ActionTypes.TOGGLE_TODO, payload: id }),\n    deleteTodo: (id) => dispatch({ type: ActionTypes.DELETE_TODO, payload: id })\n  };\n\n  return (\n    <TodoContext.Provider value={value}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// Custom Hook\nfunction useTodos() {\n  const context = useContext(TodoContext);\n  if (!context) {\n    throw new Error('useTodos must be used within TodoProvider');\n  }\n  return context;\n}\n\n// 사용\nfunction TodoList() {\n  const { todos, toggleTodo, deleteTodo } = useTodos();\n\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>\n          <input\n            type=\"checkbox\"\n            checked={todo.completed}\n            onChange={() => toggleTodo(todo.id)}\n          />\n          {todo.text}\n          <button onClick={() => deleteTodo(todo.id)}>삭제</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### Zustand (간단한 상태 관리)\n```javascript\nimport create from 'zustand';\n\n// Store 생성\nconst useStore = create((set) => ({\n  count: 0,\n  user: null,\n  \n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n  setUser: (user) => set({ user }),\n  \n  // 비동기 액션\n  fetchUser: async (id) => {\n    const response = await fetch(`/api/users/${id}`);\n    const user = await response.json();\n    set({ user });\n  }\n}));\n\n// 사용\nfunction Counter() {\n  const count = useStore((state) => state.count);\n  const increment = useStore((state) => state.increment);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>증가</button>\n    </div>\n  );\n}\n```\n\n### React Query (서버 상태 관리)\n```jsx\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\n\n// 데이터 조회\nfunction UserList() {\n  const { data, isLoading, error } = useQuery({\n    queryKey: ['users'],\n    queryFn: () => fetch('/api/users').then(res => res.json())\n  });\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <ul>\n      {data.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}\n\n// 데이터 변경\nfunction CreateUser() {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: (newUser) => \n      fetch('/api/users', {\n        method: 'POST',\n        body: JSON.stringify(newUser)\n      }),\n    onSuccess: () => {\n      // 캐시 무효화 및 재조회\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    }\n  });\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    mutation.mutate({ name: 'New User' });\n  };\n\n  return <form onSubmit={handleSubmit}>...</form>;\n}\n```\n\n## 설명\n- **Context API**: React 내장 전역 상태 관리\n- **useReducer**: 복잡한 상태 로직 관리\n- **Zustand**: 간단하고 가벼운 상태 관리 라이브러리\n- **React Query**: 서버 상태 관리 및 캐싱\n- **Redux**: 대규모 애플리케이션의 상태 관리 (별도 학습 필요)"
    }
  },
  "vue": {
    "composition-api": {
      "title": "Vue Composition API",
      "content": "# Vue Composition API\n\n## 개념\nComposition API는 Vue 3에서 도입된 새로운 API로, 로직을 재사용하고 조직하기 쉽게 만들어줍니다.\n\n## 주요 코드\n\n### setup 함수\n```vue\n<script setup>\nimport { ref, reactive, computed, watch } from 'vue';\n\n// 반응형 상태\nconst count = ref(0);\nconst user = reactive({\n  name: '홍길동',\n  age: 30\n});\n\n// 계산된 속성\nconst doubleCount = computed(() => count.value * 2);\n\n// 메서드\nconst increment = () => {\n  count.value++;\n};\n\n// watch\nwatch(count, (newValue, oldValue) => {\n  console.log(`Count changed from ${oldValue} to ${newValue}`);\n});\n</script>\n\n<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <p>Double: {{ doubleCount }}</p>\n    <button @click=\"increment\">증가</button>\n  </div>\n</template>\n```\n\n### Composables (재사용 가능한 로직)\n```javascript\n// useCounter.js\nimport { ref, computed } from 'vue';\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue);\n  const doubled = computed(() => count.value * 2);\n\n  const increment = () => count.value++;\n  const decrement = () => count.value--;\n  const reset = () => count.value = initialValue;\n\n  return {\n    count,\n    doubled,\n    increment,\n    decrement,\n    reset\n  };\n}\n\n// 사용\n<script setup>\nimport { useCounter } from './useCounter';\n\nconst { count, doubled, increment } = useCounter(0);\n</script>\n```\n\n### 라이프사이클 훅\n```vue\n<script setup>\nimport { onMounted, onUpdated, onUnmounted } from 'vue';\n\nonMounted(() => {\n  console.log('컴포넌트 마운트됨');\n});\n\nonUpdated(() => {\n  console.log('컴포넌트 업데이트됨');\n});\n\nonUnmounted(() => {\n  console.log('컴포넌트 언마운트됨');\n});\n</script>\n```\n\n### watchEffect\n```javascript\nimport { ref, watchEffect } from 'vue';\n\nconst count = ref(0);\nconst doubled = ref(0);\n\nwatchEffect(() => {\n  // 의존성 자동 추적\n  doubled.value = count.value * 2;\n  console.log(`Count: ${count.value}, Doubled: ${doubled.value}`);\n});\n```\n\n### Provide / Inject\n```vue\n<!-- 부모 컴포넌트 -->\n<script setup>\nimport { provide, ref } from 'vue';\n\nconst theme = ref('dark');\nprovide('theme', theme);\n</script>\n\n<!-- 자식 컴포넌트 -->\n<script setup>\nimport { inject } from 'vue';\n\nconst theme = inject('theme');\n</script>\n\n<template>\n  <div :class=\"theme\">Current theme: {{ theme }}</div>\n</template>\n```\n\n## 설명\n- **ref**: 원시 값을 반응형으로 만듦 (.value로 접근)\n- **reactive**: 객체를 반응형으로 만듦\n- **computed**: 계산된 값 (캐싱됨)\n- **watch**: 특정 값 변화 감지\n- **watchEffect**: 의존성 자동 추적\n- **Composables**: 재사용 가능한 로직 추출"
    }
  },
  "firebase": {
    "authentication": {
      "title": "Firebase Authentication - 사용자 인증",
      "content": "# Firebase Authentication\n\n## 개념\nFirebase Authentication은 사용자 인증을 쉽게 구현할 수 있게 해주는 서비스입니다. 이메일/비밀번호, 소셜 로그인 등 다양한 방법을 지원합니다.\n\n## 주요 코드\n\n### 초기 설정\n```javascript\nimport { initializeApp } from 'firebase/app';\nimport { getAuth } from 'firebase/auth';\n\nconst firebaseConfig = {\n  apiKey: \"your-api-key\",\n  authDomain: \"your-auth-domain\",\n  projectId: \"your-project-id\"\n};\n\nconst app = initializeApp(firebaseConfig);\nexport const auth = getAuth(app);\n```\n\n### 회원가입\n```javascript\nimport { createUserWithEmailAndPassword } from 'firebase/auth';\n\nasync function signUp(email, password) {\n  try {\n    const userCredential = await createUserWithEmailAndPassword(\n      auth,\n      email,\n      password\n    );\n    const user = userCredential.user;\n    console.log('User created:', user.uid);\n    return user;\n  } catch (error) {\n    console.error('Sign up error:', error.message);\n    throw error;\n  }\n}\n```\n\n### 로그인\n```javascript\nimport { signInWithEmailAndPassword } from 'firebase/auth';\n\nasync function signIn(email, password) {\n  try {\n    const userCredential = await signInWithEmailAndPassword(\n      auth,\n      email,\n      password\n    );\n    return userCredential.user;\n  } catch (error) {\n    console.error('Sign in error:', error.message);\n    throw error;\n  }\n}\n```\n\n### 로그아웃\n```javascript\nimport { signOut } from 'firebase/auth';\n\nasync function logout() {\n  try {\n    await signOut(auth);\n    console.log('User signed out');\n  } catch (error) {\n    console.error('Sign out error:', error.message);\n  }\n}\n```\n\n### 인증 상태 감지\n```javascript\nimport { onAuthStateChanged } from 'firebase/auth';\n\nonAuthStateChanged(auth, (user) => {\n  if (user) {\n    // 로그인됨\n    console.log('User is signed in:', user.uid);\n    console.log('Email:', user.email);\n  } else {\n    // 로그아웃됨\n    console.log('User is signed out');\n  }\n});\n```\n\n### React에서 사용\n```jsx\nimport { useState, useEffect } from 'react';\nimport { auth } from './firebase/config';\nimport { onAuthStateChanged, signOut } from 'firebase/auth';\n\nfunction useAuth() {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, (user) => {\n      setUser(user);\n      setLoading(false);\n    });\n\n    return unsubscribe;\n  }, []);\n\n  return { user, loading };\n}\n\nfunction App() {\n  const { user, loading } = useAuth();\n\n  if (loading) return <div>Loading...</div>;\n\n  return (\n    <div>\n      {user ? (\n        <div>\n          <p>Welcome, {user.email}</p>\n          <button onClick={() => signOut(auth)}>로그아웃</button>\n        </div>\n      ) : (\n        <div>Please sign in</div>\n      )}\n    </div>\n  );\n}\n```\n\n### Vue에서 사용\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue';\nimport { auth } from './firebase/config';\nimport { onAuthStateChanged, signOut } from 'firebase/auth';\n\nconst user = ref(null);\nconst loading = ref(true);\n\nonMounted(() => {\n  onAuthStateChanged(auth, (currentUser) => {\n    user.value = currentUser;\n    loading.value = false;\n  });\n});\n\nconst logout = async () => {\n  await signOut(auth);\n};\n</script>\n\n<template>\n  <div>\n    <div v-if=\"loading\">Loading...</div>\n    <div v-else-if=\"user\">\n      <p>Welcome, {{ user.email }}</p>\n      <button @click=\"logout\">로그아웃</button>\n    </div>\n    <div v-else>Please sign in</div>\n  </div>\n</template>\n```\n\n## 설명\n- **createUserWithEmailAndPassword**: 이메일/비밀번호로 회원가입\n- **signInWithEmailAndPassword**: 이메일/비밀번호로 로그인\n- **signOut**: 로그아웃\n- **onAuthStateChanged**: 인증 상태 변화 감지\n- **currentUser**: 현재 로그인한 사용자 정보"
    },
    "firestore": {
      "title": "Firestore - NoSQL 데이터베이스",
      "content": "# Firestore\n\n## 개념\nFirestore는 Firebase의 NoSQL 클라우드 데이터베이스입니다. 실시간 동기화와 오프라인 지원을 제공합니다.\n\n## 주요 코드\n\n### 초기 설정\n```javascript\nimport { getFirestore } from 'firebase/firestore';\n\nexport const db = getFirestore(app);\n```\n\n### 데이터 추가\n```javascript\nimport { collection, addDoc, setDoc, doc } from 'firebase/firestore';\n\n// 자동 ID 생성\nasync function addUser(userData) {\n  try {\n    const docRef = await addDoc(collection(db, 'users'), userData);\n    console.log('Document written with ID:', docRef.id);\n    return docRef.id;\n  } catch (error) {\n    console.error('Error adding document:', error);\n  }\n}\n\n// 커스텀 ID 사용\nasync function setUser(userId, userData) {\n  try {\n    await setDoc(doc(db, 'users', userId), userData);\n    console.log('Document written with custom ID:', userId);\n  } catch (error) {\n    console.error('Error setting document:', error);\n  }\n}\n```\n\n### 데이터 조회\n```javascript\nimport { doc, getDoc, collection, getDocs, query, where } from 'firebase/firestore';\n\n// 단일 문서 조회\nasync function getUser(userId) {\n  const docRef = doc(db, 'users', userId);\n  const docSnap = await getDoc(docRef);\n\n  if (docSnap.exists()) {\n    console.log('Document data:', docSnap.data());\n    return docSnap.data();\n  } else {\n    console.log('No such document!');\n    return null;\n  }\n}\n\n// 전체 컬렉션 조회\nasync function getAllUsers() {\n  const querySnapshot = await getDocs(collection(db, 'users'));\n  const users = [];\n  querySnapshot.forEach((doc) => {\n    users.push({ id: doc.id, ...doc.data() });\n  });\n  return users;\n}\n\n// 조건부 조회\nasync function getActiveUsers() {\n  const q = query(\n    collection(db, 'users'),\n    where('active', '==', true),\n    where('age', '>=', 18)\n  );\n  const querySnapshot = await getDocs(q);\n  const users = [];\n  querySnapshot.forEach((doc) => {\n    users.push({ id: doc.id, ...doc.data() });\n  });\n  return users;\n}\n```\n\n### 데이터 업데이트\n```javascript\nimport { doc, updateDoc } from 'firebase/firestore';\n\nasync function updateUser(userId, updates) {\n  const docRef = doc(db, 'users', userId);\n  try {\n    await updateDoc(docRef, updates);\n    console.log('Document updated');\n  } catch (error) {\n    console.error('Error updating document:', error);\n  }\n}\n\n// 사용 예\nupdateUser('user123', {\n  age: 31,\n  'address.city': 'Seoul' // 중첩 필드 업데이트\n});\n```\n\n### 데이터 삭제\n```javascript\nimport { doc, deleteDoc } from 'firebase/firestore';\n\nasync function deleteUser(userId) {\n  try {\n    await deleteDoc(doc(db, 'users', userId));\n    console.log('Document deleted');\n  } catch (error) {\n    console.error('Error deleting document:', error);\n  }\n}\n```\n\n### 실시간 리스너\n```javascript\nimport { doc, onSnapshot } from 'firebase/firestore';\n\n// 단일 문서 실시간 감지\nfunction listenToUser(userId, callback) {\n  const unsubscribe = onSnapshot(doc(db, 'users', userId), (doc) => {\n    if (doc.exists()) {\n      callback({ id: doc.id, ...doc.data() });\n    }\n  });\n  \n  return unsubscribe; // 리스너 해제 함수\n}\n\n// 컬렉션 실시간 감지\nfunction listenToUsers(callback) {\n  const unsubscribe = onSnapshot(collection(db, 'users'), (snapshot) => {\n    const users = [];\n    snapshot.forEach((doc) => {\n      users.push({ id: doc.id, ...doc.data() });\n    });\n    callback(users);\n  });\n  \n  return unsubscribe;\n}\n```\n\n### React에서 사용\n```jsx\nimport { useState, useEffect } from 'react';\nimport { collection, onSnapshot } from 'firebase/firestore';\nimport { db } from './firebase/config';\n\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const unsubscribe = onSnapshot(\n      collection(db, 'users'),\n      (snapshot) => {\n        const usersData = [];\n        snapshot.forEach((doc) => {\n          usersData.push({ id: doc.id, ...doc.data() });\n        });\n        setUsers(usersData);\n        setLoading(false);\n      },\n      (error) => {\n        console.error('Error fetching users:', error);\n        setLoading(false);\n      }\n    );\n\n    return () => unsubscribe();\n  }, []);\n\n  if (loading) return <div>Loading...</div>;\n\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## 설명\n- **addDoc**: 자동 ID로 문서 추가\n- **setDoc**: 커스텀 ID로 문서 설정\n- **getDoc**: 단일 문서 조회\n- **getDocs**: 여러 문서 조회\n- **updateDoc**: 문서 업데이트\n- **deleteDoc**: 문서 삭제\n- **onSnapshot**: 실시간 데이터 감지\n- **query/where**: 조건부 쿼리"
    }
  }
}
